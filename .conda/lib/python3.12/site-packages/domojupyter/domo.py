from uuid import UUID

from traitlets.config.configurable import LoggingConfigurable

import os
import requests
import json
import urllib.parse
import time
import gzip


def _is_valid_uuid(uuid_to_test, version=4):
    """
    Check if uuid_to_test is a valid UUID.
    """
    try:
        uuid_obj = UUID(uuid_to_test, version=version)
    except ValueError:
        return False
    return str(uuid_obj) == uuid_to_test


class Domo(LoggingConfigurable):

    def __init__(self, domo_hostname, domo_authentication, workspace_id, **kwargs):
        self._auth = domo_authentication
        if _is_valid_uuid(workspace_id):
            self.workspace_id = workspace_id
        else:
            raise Exception('WorkspaceId is not a valid UUID.')
        if domo_hostname is None:
            raise Exception('Domo hostname not configured.')

        self._domo_hostname = domo_hostname

    def _add_auth_headers(self, headers):
        auth_headers = self._auth.get_auth_headers()
        return {**headers, **auth_headers}

    def _get(self, url, headers={'Accept': 'application/json'}):
        headers = self._add_auth_headers(headers)
        return requests.get(url, headers=headers)

    def _put(self, url, data, headers={'Accept': 'application/json'}):
        headers = self._add_auth_headers(headers)
        return requests.put(url, json=data, headers=headers)

    def _put_bytes(self, url, data, headers={'Accept': 'application/json'}):
        headers = self._add_auth_headers(headers)
        return requests.put(url, data=data, headers=headers)

    def _post(self, url, data, headers={'Accept': 'application/json'}):
        headers = self._add_auth_headers(headers)
        return requests.post(url, json=data, headers=headers)

    def _post_no_json(self, url, data, headers=None):
        if headers is None:
            headers = {}
        headers = self._add_auth_headers(headers)
        return requests.post(url, data=data, headers=headers)

    def _post_data(self, url, data, headers={'Accept': 'application/json'}):
        headers = self._add_auth_headers(headers)
        return requests.post(url, data=data, headers=headers)

    def _post(self, url, data, headers={'Accept': 'application/json'}):
        headers = self._add_auth_headers(headers)
        return requests.post(url, json=data, headers=headers)

    def _delete(self, url, headers={'Accept': 'application/json'}):
        headers = self._add_auth_headers(headers)
        return requests.delete(url, headers=headers)

    def export_datasource(self, datasource_id, query=None):
        if not _is_valid_uuid(datasource_id):
            raise Exception('datasourceId is not a valid UUID.')

        datasource_url = f'{self._domo_hostname}/api/query/v1/execute/export/{datasource_id}'

        if query:
            body = {'sql': query}
            r = self._post(datasource_url, body, {'Accept': 'text/csv,application/json;q=0.1'})
        else:
            r = self._get(datasource_url, {'Accept': 'text/csv,application/json;q=0.1'})
        data = r.content.decode('utf-8')
        if r.status_code != 200 or data is None:
            raise Exception(f'Failed to obtain data: {r.status_code} {data}')

        return data

    def get_workspace(self):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}'
        headers = {
            'Accept': 'application/json'
        }
        r = self._get(url, headers)
        workspace = r.json()
        if r.status_code != 200 or workspace is None:
            raise Exception(f'Failed to obtain workspace {self.workspace_id} {r.json()}')

        return r.json()

    def get_schema(self, datasource_id):
        if not _is_valid_uuid(datasource_id):
            raise Exception('datasourceId is not a valid UUID.')

        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/data/{datasource_id}/schema'
        headers = {
            'Accept': 'application/json'
        }
        r = self._get(url, headers)
        schema = r.json()
        if r.status_code != 200 or schema is None:
            raise Exception(f'Failed to obtain schema {r.json()}')

        if schema:
            return {'columns': [{'name': col.get('name'), 'type': col.get('type')} for col in schema.get('columns')],
                    'objects': schema.get('objects')}
        return {}

    def update_schema(self, datasource_id, schema):
        if not _is_valid_uuid(datasource_id):
            raise Exception('datasourceId is not a valid UUID.')
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/data/{datasource_id}/schema'
        r = self._put(url, schema, {'Content-Type': 'application/json'})

        if r.status_code != 200:
            raise Exception(f'Failed to update schema: {r.status_code} {r.json()}')

        return

    def create_execution(self, datasource_id, update_method):
        if not _is_valid_uuid(datasource_id):
            raise Exception('datasourceId is not a valid UUID.')
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/data/{datasource_id}/executions?updateMethod={update_method}'
        r = self._post(url, data=None)
        execution = r.json()
        execution_id = execution.get('executionId', None)

        if r.status_code != 201 or execution_id is None:
            raise Exception(f'Failed to start upload execution: {r.status_code} {r.json()}')

        return execution

    def commit_execution(self, datasource_id, execution_id, partition_name):
        if not _is_valid_uuid(datasource_id):
            raise Exception('datasourceId is not a valid UUID.')

        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/data/{datasource_id}/executions/{execution_id}/commit'
        if partition_name is not None:
            url += f'?partitionName={partition_name}'
        r = self._put(url, None)
        execution = r.json()

        if r.status_code >= 400 or execution is None:
            raise Exception(f'Failed to commit upload execution: {r.status_code} {execution}')

        return execution

    def upload_part(self, datasource_id, execution_id, part_id, data):
        if not _is_valid_uuid(datasource_id):
            raise Exception('datasourceId is not a valid UUID.')

        compressed = gzip.compress(bytes(data, 'utf-8'))
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/data/{datasource_id}/executions/{execution_id}/part/{part_id}'

        r = self._put_bytes(url, compressed, {'Content-Type': 'application/octet-stream'})
        execution = r.json()

        if r.status_code != 200 or execution is None:
            raise Exception(f'Failed to upload part: {r.status_code} {execution}')

        return execution

    def _access_token(self):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/auth/token'
        headers = {
            'Accept': 'application/json'
        }
        r = self._get(url, headers=headers)
        r.raise_for_status()
        return r.json()

    def get_account_properties(self, account_id):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/account/{account_id}'
        headers = {
            'Accept': 'application/json'
        }
        r = self._get(url, headers)
        workspace = r.json()
        if r.status_code == 403:
            raise Exception(
                f'Permissions denied for workspace: {self.workspace_id}, accountId: {account_id} {r.json()}')
        if r.status_code != 200 or workspace is None:
            raise Exception(
                f'Failed to obtain workspace account properties for workspace: {self.workspace_id}, accountId: {account_id} {r.json()}')

        return r.json()

    def get_document(self, collection_id, document_id):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/collection/{collection_id}/document/{document_id}'
        headers = {
            'Accept': 'application/json'
        }
        r = self._get(url, headers)
        workspace = r.json()
        if r.status_code == 403:
            raise Exception(
                f'Permissions denied for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')
        if r.status_code != 200 or workspace is None:
            raise Exception(
                f'Failed to obtain workspace document- {document_id}, for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')

        return r.json()

    def get_documents(self, collection_id, offset, limit):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/collection/{collection_id}/documents?offset={offset}&limit={limit}'
        headers = {
            'Accept': 'application/json'
        }
        r = self._get(url, headers)
        workspace = r.json()
        if r.status_code == 403:
            raise Exception(
                f'Permissions denied for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')
        if r.status_code != 200 or workspace is None:
            raise Exception(
                f'Failed to obtain documents for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')

        return r.json()

    def query_documents(self, collection_id, document_query):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/collection/{collection_id}/query'
        headers = {
            'Accept': 'application/json'
        }
        r = self._post(url, document_query, headers)
        documents = r.json()
        if r.status_code == 403:
            raise Exception(
                f'Permissions denied for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')
        if r.status_code != 200 or documents is None:
            raise Exception(
                f'Failed to obtain documents for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')

        return r.json()

    def create_document(self, collection_id, document):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/collection/{collection_id}/document'
        headers = {
            'Accept': 'application/json'
        }
        r = self._post(url, data=document, headers=headers)
        if r.status_code == 403:
            raise Exception(
                f'Permissions denied for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')
        if r.status_code != 200:
            raise Exception(
                f'Failed to create document - {document}, for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')

    def create_documents(self, collection_id, documents):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/collection/{collection_id}/documents'
        headers = {
            'Accept': 'application/json'
        }
        r = self._post(url, documents, headers)
        if r.status_code == 403:
            raise Exception(
                f'Permissions denied for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')
        if r.status_code != 200:
            raise Exception(
                f'Failed to create documents- {documents}, for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')

    def delete_document(self, collection_id, document_id):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/collection/{collection_id}/delete/document/{document_id}'
        headers = {
            'Accept': 'application/json'
        }
        r = self._post(url, headers)
        if r.status_code == 403:
            raise Exception(
                f'Permissions denied for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')
        if r.status_code != 200:
            raise Exception(
                f'Failed to obtain workspace document- {document_id}, for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')

    def delete_documents(self, collection_id, document_ids):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/collection/{collection_id}/delete/documents'
        headers = {
            'Accept': 'application/json'
        }
        r = self._post(url, document_ids, headers)
        if r.status_code == 403:
            raise Exception(
                f'Permissions denied for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')
        if r.status_code != 200:
            raise Exception(
                f'Failed to delete documents - {document_ids}, for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')

    def update_document(self, collection_id, document_update):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/collection/{collection_id}/document'
        headers = {
            'Accept': 'application/json'
        }
        r = self._put(url, document_update, headers)
        if r.status_code == 403:
            raise Exception(
                f'Permissions denied for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')
        if r.status_code != 200:
            raise Exception(
                f'Failed to update document, documentUpdate - {document_update}, for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')

    def update_documents(self, collection_id, documents):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{self.workspace_id}/collection/{collection_id}/update/documents'
        headers = {
            'Accept': 'application/json'
        }
        r = self._put(url, documents, headers)
        if r.status_code == 403:
            raise Exception(
                f'Permissions denied for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')
        if r.status_code != 200:
            raise Exception(
                f'Failed to update documents - {documents}, for workspace: {self.workspace_id}, collectionId: {collection_id} {r.json()}')

    def create_snapshot(self, create_snapshot_request, workspace_id):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{workspace_id}/snapshots'
        headers = {
            'Accept': 'application/json'
        }
        r = self._post(url, create_snapshot_request, headers)
        if r.status_code != 200:
            raise Exception(
                f'Failed to create snapshot for request: {create_snapshot_request} - {r.json()}')
        return r.json()

    def list_snapshots(self, workspace_id):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{workspace_id}/snapshots'
        headers = {
            'Accept': 'application/json'
        }
        r = self._get(url, headers)
        if r.status_code != 200:
            raise Exception(
                f'Failed to list snapshots: {r.json()}')
        return r.json()

    def create_model(self, create_model_request, workspace_id):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{workspace_id}/models'
        headers = {
            'Accept': 'application/json'
        }
        r = self._post(url, create_model_request, headers)
        if r.status_code != 201:
            raise Exception(
                f'Failed to create model for request: {create_model_request} - {r.json()}')
        return r.json()

    def upload_model_package(self, model_id, workspace_id, zipped_model):
        url = f'{self._domo_hostname}/api/datascience/v1/workspaces/{workspace_id}/models/{model_id}/package'
        r = self._post_no_json(url, zipped_model, headers={"Accept": "application/octet-stream",
                                                           "Content-Length": len(zipped_model).__str__()})
        if r.status_code != 204:
            raise Exception(
                f'Failed to upload model package: {zipped_model}')


class DomoAuthentication(object):

    def get_auth_headers(self):
        """Headers for authenticated requests"""


class DomoDevTokenAuthentication(DomoAuthentication):
    def __init__(self, dev_token):
        self.dev_token = dev_token

    def get_auth_headers(self):
        return {'X-DOMO-Developer-Token': self.dev_token}


class DomoHubAuthentication(DomoAuthentication):
    token_expiration_buffer = 30

    def __init__(self, jupyterhub):
        self._jupyterhub = jupyterhub
        self._access_token = None

    @property
    def access_token(self):
        if self._is_access_token_expired():
            self._get_new_token()

        return self._access_token

    @property
    def access_token_expiration(self):
        return self._access_token_expiration

    def get_auth_headers(self):
        return {'Authorization': f'Bearer {self.access_token}'}

    def _get_new_token(self):
        request_time = int(time.time())
        token_response = self._jupyterhub.get_domo_access_token()
        self._access_token = token_response['access_token']
        expires_in = token_response['expires_in']
        self._access_token_expiration = request_time + int(expires_in)

    def _is_access_token_expired(self):
        if self._access_token is None or self._access_token_expiration is None:
            return True

        if self._access_token_expiration < (time.time() + self.token_expiration_buffer):
            return True
        return False


class DomoResourceTokenAuthentication(DomoAuthentication):
    def __init__(self, resource_token):
        self.resource_token = resource_token

    def get_auth_headers(self):
        return {'X-DOMO-Resource-Token': self.resource_token}


class DomoDataflowAuthentication(DomoAuthentication):
    token_expiration_buffer = 30

    def __init__(self, domo, workspace_id):
        self._domo = domo
        self._workspace_id = workspace_id
        self._access_token = None

    @property
    def access_token(self):
        if self._is_access_token_expired():
            self._get_new_token()

        return self._access_token

    @property
    def access_token_expiration(self):
        return self._access_token_expiration

    def get_auth_headers(self):
        return {'Authorization': f'Bearer {self.access_token}'}

    def _get_new_token(self):
        request_time = int(time.time())
        token_response = self._domo._access_token()
        self._access_token = token_response['access_token']
        expires_in = token_response['expires_in']
        self._access_token_expiration = request_time + int(expires_in)

    def _is_access_token_expired(self):
        if self._access_token is None or self._access_token_expiration is None:
            return True

        if self._access_token_expiration < (time.time() + self.token_expiration_buffer):
            return True
        return False
